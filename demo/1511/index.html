<!DOCTYPE html>
<html>
  <head>
    <link href="style.css" rel="stylesheet"></link>
  </head>
  <body>
    <h1>LINKED LISTS</h1>
    <div class="d-flex">
      <div class="left">
        <span>TOOLS</span>
        <br>
        <br>
        <button id="new_list">    <pre>struct node *list;           // make a new list</pre></button>
        <button id="new_ball">    <pre>malloc(sizeof(struct node)); // make a new node</pre></button>
        <button id="free_ball">   <pre>free(node);                  // remove a new node</pre></button>
        <button id="new_link">    <pre>node->next = another_node;   // connect two nodes</pre></button>
        <button id="point_list">  <pre>list = node;                 // point list to a node</pre></button>
        <br>
        <br>
        <div id="lists"></div>
      </div>
      <div class="middle">
        <canvas width="800" height="600" id="display"></canvas>
      </div>
      <div class="right">
        <select name="code_select" id="code_select">
          <option value="intro">Introduction</option>
          <option value="nth_delete">Nth Delete</option>
        </select>
        <textarea id="intro" class="code">
This website showcases a live visual
demonstration of how linked lists work.

Each colored circle represents a node allocation
on the heap. The arrows represent pointers which
point each node to the next. The fixed static
black circles are locally declared list pointers.
These are generally created by being declared as
variables.  Whether as a local variable on a stack
or as part of a struct.

On the left hand side is a variety of buttons
which perform fundamental operations on linked
lists.
        </textarea>
        <textarea id="nth_delete" hidden class="code">
// Returns the new head
struct node *nth_delete(struct node *head, int n) {
  // The list doesn't exist there's nothing
  // to delete
  if (!head) {
    return head;
  }
  
  struct node *prev = NULL;
  struct node *current = head;
  
  int i = 0;
  while (i < n && current) {
    i++;
    prev = current;
    current = current->next;
  }
  
  // n is greater than size. don't do anything
  if (!current) {
    return head;
  }
  
  struct node *next = current->next;
  free(current);
  
  // if there's no previous element
  // it is at the beginning of the list
  // return next as the new head
  if (!prev) {
    return next;
  }
  
  prev->next = next;
  return head;
}
        </textarea>
      </div>
    </div>
    <script src="main.js" type="module"></script>
  </body>
</html>
