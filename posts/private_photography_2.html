<html>
	<head>
		<title>DEMOS - vv4t</title>
		<link rel="shortcut icon" type="image/png" href="/assets/favicon.png"/>
		<link rel="stylesheet" href="/css/page.css">
		<link rel="stylesheet" href="/posts/article.css">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.0/css/all.css" integrity="sha384-lZN37f5QGtY3VHgisS14W3ExzMWZxybE1SJSEsQp9S+oqd12jhcu+A56Ebc1zFSJ" crossorigin="anonymous">
		<meta charset="utf-8">
	</head>
  <body>
    <iframe src="/nav.html"></iframe>
		<div class="main">
			<h1>LOGIN</h1>
      <br>
      <input style="background-color: black; color: white; font-size: 20px;" type="password" id="pwd" placeholder="Password">
    </div>
    <script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js"></script>
<script>
function page_login(pwd)
{
  const key = gen_pwd(pwd, "abc123!@#");
  const aes_ctr = new aesjs.ModeOfOperation.ctr(key);
  
  // note that decrypting the verification and the contents use the same
  // 'aes_ctr' so order is important. this is also to be the case when
  // encrypting in 'sscrpted.js'
  
  // decrypt the verification string to test if the password is correct
  const str_verify = "5c2b1a2d51b9d38126af349bd33981eba7cbaa9df017d03fe0eecd163874d8ba5e3ea03953b5ffdba31492762d6d19";
  const key_verify = aesjs.utils.utf8.fromBytes(aes_ctr.decrypt(aesjs.utils.hex.toBytes(str_verify)));
  
  if (key_verify != "minna chiruno no sansei kyoushitsu hajimaru yo~")
    return false;
  
  // decrypt the contents and load them into a 'html' element
  const payload = "f3390c86323a6fee148f145e9c2b24bcc48b6b361bf017fe743be1b714a70e76d436677ca2cd98918305f6584820537de881e7027bfe3b57c642e570257ef06daadc755c5fa0ffacc18e0007f594e7ff6c40284fb057ccadd4e14a5a8c6c6ae8e0bdac4d8925c73594f377ddb0b946fb3ae8b793e71aeed402f7f953dfefd57904ccff0303b1249d0e049298945b5a6628e8f310d6128e0d2834986eb8cc77247208b264358578424d8b1b58d3210b9c61b3659cf033aa3884b98491da23a4113ea7aa25a931afada0ca9220072e2aa9abbb15d5d2f791cc3836ec5d80f68ab309b60c157a8da6089174b6fc35c6af76d5d706415e6961fe2482c567a8a1dc4a6eb38d6628d4e2bfdfbc38bed43c540156e765d930e0002050b400fe7a581ecba47c4dd9edc4f29928918e8162b492c07721837078a05832841573162abeb03ca4386e532f2964205cb3f8a9afb1ea0123fdbf2ab7053fec9ab7fb1ab41ffa69eae1ce01d2a860eb2ef68d6edf26f7b6042435aeb1d9c2516bbd7b411debcbe5536d44a999d5e20a612ba7a18ad7641486f1bdb61a2038835f1bc554fc2908c0b63a59441030358811679d8527d71be7f0acb7ff3f52cbaa1611c7cc720abe85a02108288812025d601aeeba1d3e3bfbc5cbdbb759b7f1fd22a2d0b54b3ed91c4571289c191a1869335b73aa02b24d105896522841e53eb965bd34e55c2811a79449d5b224b0a1bc67ae227bc847d2e22c5a457da2bbc225f78f53e77062f28e3b98733c3ab91ed2c4399f7e3c1241bf07d53630f7879a2294a028835cc651c2aa45ece9170d8fdc866aa540705fa88faa8642034565d5e12cb98f525304344821e565f553152632cca8c9335dad893fcc7f873f8d5cb631d3aee233d0ce85c7e4ac3a5b1aaf4fac51bf61c06fa47deaf692ef1f31a84747cb17ea41d283bea7db97704877ff4c1726e06995d7eb217597197af75dc1f0ebb0da19cb27bc38eac5ad58830d88e3034d66d2db8e6d49124c22413c2d32cadd8b02fc741fb1d3f3fe4ed7acb7714b5c07ad598dd853aa410a1a7386019fafe21000e45a2e7e936971c479691af4ae86f54653c21ce38822759c2967c08d0fa00a4c4c817b47ce7795fad8a1f454123800de4b32f97c22697dbf364392ebfd6f0d9166e70003c8d94fbb965631fe1b9ad33d1c7b754a99bcf407e47f4029c1b873a8279c236741186872a3b260aa1043e9f87dee77d554ad805c52190e20a39d3001d5570008df6a2ec21df1b5c39e8f97c6181962ed5ef103ef07971ad9bc6723736ff0f4daa7a37072464fbdeca3f0041ef03c5c2958550834ca387a74274d38ce1fb6487c95c2bef00bc25b27480a26b403aeb26bc2a6dd74035d5761b36d866bb1525de4c284d073d8dea9167c948b45f68869b47b767165435202da8bfdabeb25f80747c9be28b598d25bf633f654a7fccf2e942b6c3b34bd86f7251e2f1049d8e364fc45cc078967f311c5c47e666f3464a1dcc08f0519a159690648c8f13fdcd8db7ab45fc91dd88f3c92809381c8";
  const content = aesjs.utils.utf8.fromBytes(aes_ctr.decrypt(aesjs.utils.hex.toBytes(payload)));
  const html = document.createElement("html");
  html.innerHTML = content;
  
  // delete all existing nodes
  document.head.innerHTML = "";
  document.body.innerHTML = "";
  
  // copy the contents of the 'html' element into the DOM
  while (html.children[0].childNodes.length)
    document.head.appendChild(html.children[0].childNodes[0]);
  while (html.children[1].childNodes.length)
    document.body.appendChild(html.children[1].childNodes[0]);

  // recursively traverse the nodes to load in encrypted assets and load
  // scripts
  unpack_node(document.head, key);
  unpack_node(document.body, key);
  
  return true;
}

// generate a key using scrypt
function gen_pwd(pwd, salt)
{
  const bytes_pwd = aesjs.utils.utf8.toBytes(pwd.normalize("NFKC"));
  const bytes_salt = aesjs.utils.utf8.toBytes(salt.normalize("NFKC"));

  const N = 1024, r = 8, p = 1;
  const dkLen = 32;
  
  return scrypt.syncScrypt(bytes_pwd, bytes_salt, N, r, p, dkLen);
}

async function unpack_node(node, key)
{
  for (const child_node of node.children) {
    // ensure that all child nodes are walked first to prevent data from being
    // overwritten potentially
    unpack_node(child_node, key);
    
    // asynchronously load all encrypted resources referenced in 'href' or 'src'
    const node_href = await load_attribute_resource(child_node, "href", key);
    const node_src = await load_attribute_resource(child_node, "src", key);
    
    await Promise.all([node_href, node_src]);
    
    if (node_href)
      child_node.setAttribute("href", node_href);
    if (node_src)
      child_node.setAttribute("src", node_src);
  }
  
  reload_js(node);
}

async function load_attribute_resource(node, attr, key)
{
  return new Promise((resolve, reject) => {
    const reg_exp = new RegExp(/{{{\$encrypt\:(.+)}}}/gm);
    const node_attr = node.getAttribute(attr);
    const match_attr = reg_exp.exec(node_attr);
    
    if (node_attr && match_attr) {
      decrypt_resource(key, match_attr[1]).then((blob_url) => {
        resolve(blob_url);
      });
    } else {
      // this node doesn't have the specified attribute or doesn't use an
      // encrypted resource 
      resolve(null);
    }
  });
}

// because encrypted 'js' is loaded in after the DOM page has already loaded,
// they need to be ran again. this can be done by copying the script node and
// replacing the current one
function reload_js(node)
{
  // load them into an array to prevent altering the node while it is being
  // iterated on
  const to_add = [];
  const to_remove = [];
  
  for (const child_node of node.children) {
    if (child_node.nodeName == "SCRIPT") {
      const new_script_node = document.createElement("SCRIPT");
      new_script_node.innerText = child_node.innerText;
      if (child_node.src)
        new_script_node.src = child_node.src;
      
      to_remove.push(child_node);
      to_add.push(new_script_node);
    }
  }
  
  // apply changes
  for (const script_node of to_remove)
    node.removeChild(script_node);
  
  for (const script_node of to_add)
    node.appendChild(script_node);
}

async function decrypt_resource(key, url)
{
  return new Promise((resolve, reject) => {
    const enc_bin_url = url + ".enc";
    
    // load the contents of the encrypted asset using XHR
    // this means it may not work on local html pages due to CORS and needs to
    // be hosted
    
    const xhr = new XMLHttpRequest();
    xhr.open("GET", enc_bin_url);
    xhr.responseType = 'arraybuffer';
    
    xhr.onload = (e) => {
      const enc_text = new Uint8Array(xhr.response);
      
      const aes_ctr = new aesjs.ModeOfOperation.ctr(key);
      const byte_array = aes_ctr.decrypt(enc_text);
      
      const blob = new Blob([byte_array]);
      const blob_url = URL.createObjectURL(blob);
      
      resolve(blob_url);
    };
    
    xhr.send();
  });
}
</script>

    <script>
      const input_pwd = document.getElementById("pwd");
      pwd.addEventListener("keyup", (e) => {
        if (e.key == "Enter") {
          if (!page_login(pwd.value))
            alert("incorrect password");
        }
      });
    </script>
	</body>
</html>
