<html>
	<head>
		<title>DEMOS - vv4t</title>
		<link rel="shortcut icon" type="image/png" href="/assets/favicon.png"/>
		<link rel="stylesheet" href="/css/page.css">
		<link rel="stylesheet" href="/posts/article.css">
		<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.0/css/all.css" integrity="sha384-lZN37f5QGtY3VHgisS14W3ExzMWZxybE1SJSEsQp9S+oqd12jhcu+A56Ebc1zFSJ" crossorigin="anonymous">
		<meta charset="utf-8">
	</head>
  <body>
    <iframe src="/nav.html"></iframe>
		<div class="main">
			<h1>LOGIN</h1>
      <br>
      <input style="background-color: black; color: white; font-size: 20px;" type="password" id="pwd" placeholder="Password">
    </div>
    <script type="text/javascript" src="https://cdn.rawgit.com/ricmoo/aes-js/e27b99df/index.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js"></script>
<script>
function page_login(pwd)
{
  const key = gen_pwd(pwd, "abc123!@#");
  const aes_ctr = new aesjs.ModeOfOperation.ctr(key);
  
  // note that decrypting the verification and the contents use the same
  // 'aes_ctr' so order is important. this is also to be the case when
  // encrypting in 'sscrpted.js'
  
  // decrypt the verification string to test if the password is correct
  const str_verify = "2d3fcae252b93373bdce6ef4503e95e1c8ecfdd6db0ac4801b45510ea11d8a95c2711235ba73d43fa2208ecd48b704";
  const key_verify = aesjs.utils.utf8.fromBytes(aes_ctr.decrypt(aesjs.utils.hex.toBytes(str_verify)));
  
  if (key_verify != "minna chiruno no sansei kyoushitsu hajimaru yo~")
    return false;
  
  // decrypt the contents and load them into a 'html' element
  const payload = "3ba9b8b9d6108c9339946ba63476aa4c6449c3963bdb339111be0200caa127e29f47a42ef0769671fe1594aef78195cb18e85bdc96bab9a4986ac1f77ce225394da233f7d99ac91eb97fdf7d2cfbab1c7cc70a74375c386fd7146f22f6fc20f795a6545f107b3b0b679ff133ef272545174f98bef8cfb2f71246d4c366eb075c3ffebd152b0e7dfafc7f7adf33993671c713e75fa17027738643c2a320fa9ba132e90d614eaaa10c85a689a85d6323bc18a7547a0f786eebba9f9fae9aeef0b64c505d47ee1279e661380971114e6eb3e4b76b4d1023d00ea9d61f70b379b3f60b64937b3530a3f5f3cd3eef74799fe8161a57c7dcfe9e24e3a138ff7f319b04b6b3e08c88da731e04aaefc2296a72cea28601600ac52e4c11d2c8d1868cc7a81d05bcecac09887efaa48a45074b9fca36a44e0dc9ac4903e5486c805d90a8207393b024f61be9d19908c4f8b255e2077505584a5ca74a3c3aee3a9cf206edae100ef0f74c463eeff47b0392ae38b917afcd381775db69d681279eb180ff3bee22ece71ccc46410e474003aafc92fb8978697c5b87246db54f27b9a81242cc1e08156b06e3d459c4219444d1ccf8f0c6d0609d715ccd05beb32cbac718d84d7f2a919d22816ab26d5eef1991eb48066517658df75e0c43e42a6a08ebb4e2c429a75b6513a835e045f54f230f414b3131968b6245ee03faefbe47f7772f388acbaa590a9e541aecddebe9853d737a16f9b3616543774416b819055210e8d961acc82b98f0af260a6959b966c4ae9247b2704fa544b64149bcf863f67cbbbfb651b04eddc1b840c9933dbf48d17ae3a774b83b7ba5c9706778993f847e7a50cd77df381251a9a313ef7f9aefa955d1f5bd56f9c4e99c343d8a1de7de1f5220546cee30995f074dbe83b1ff51769cdd08bc264664466dc5c67736d28afa18ecc088521acca5ff629639056c969dc4694a64a76740bf0a6a796323633567c1f0b490342c82eacff51a02852d9c5432c488ad79e5a269ecbf2fdb1eb5d30ab3a446c1d5617993c413602927f656b0b1443df3afe192825c6bf976f80a94c63896e3df90cca6ec4804b638d45f66d563f2a853697346cb1a6b7bd9bd9a737dcb55824ae7f8ed5dc5cb55c5c5cd7417d46fbe45764afb15f9a182fc6f282692bf9185284042c0df4e8c8838f0283f0d2ebd7e90853df91d9e877e13e7c87c1b98432fa3c7436c1e4ba1a3f4e05e2379d0ae3d8b0e91516df2ec0f83ace397ecb080c3ab42e1cb61c3d47a4169e94aacdea1ebcd68afd41b3a729990348774c93456b1587c96e90e46f47ee2e61dd9504c102afb8626e5b1b65a53d3";
  const content = aesjs.utils.utf8.fromBytes(aes_ctr.decrypt(aesjs.utils.hex.toBytes(payload)));
  const html = document.createElement("html");
  html.innerHTML = content;
  
  // delete all existing nodes
  document.head.innerHTML = "";
  document.body.innerHTML = "";
  
  // copy the contents of the 'html' element into the DOM
  while (html.children[0].childNodes.length)
    document.head.appendChild(html.children[0].childNodes[0]);
  while (html.children[1].childNodes.length)
    document.body.appendChild(html.children[1].childNodes[0]);

  // recursively traverse the nodes to load in encrypted assets and load
  // scripts
  unpack_node(document.head, key);
  unpack_node(document.body, key);
  
  return true;
}

// generate a key using scrypt
function gen_pwd(pwd, salt)
{
  const bytes_pwd = aesjs.utils.utf8.toBytes(pwd.normalize("NFKC"));
  const bytes_salt = aesjs.utils.utf8.toBytes(salt.normalize("NFKC"));

  const N = 1024, r = 8, p = 1;
  const dkLen = 32;
  
  return scrypt.syncScrypt(bytes_pwd, bytes_salt, N, r, p, dkLen);
}

async function unpack_node(node, key)
{
  for (const child_node of node.children) {
    // ensure that all child nodes are walked first to prevent data from being
    // overwritten potentially
    unpack_node(child_node, key);
    
    // asynchronously load all encrypted resources referenced in 'href' or 'src'
    const node_href = await load_attribute_resource(child_node, "href", key);
    const node_src = await load_attribute_resource(child_node, "src", key);
    
    await Promise.all([node_href, node_src]);
    
    if (node_href)
      child_node.setAttribute("href", node_href);
    if (node_src)
      child_node.setAttribute("src", node_src);
  }
  
  reload_js(node);
}

async function load_attribute_resource(node, attr, key)
{
  return new Promise((resolve, reject) => {
    const reg_exp = new RegExp(/{{{\$encrypt\:(.+)}}}/gm);
    const node_attr = node.getAttribute(attr);
    const match_attr = reg_exp.exec(node_attr);
    
    if (node_attr && match_attr) {
      decrypt_resource(key, match_attr[1]).then((blob_url) => {
        resolve(blob_url);
      });
    } else {
      // this node doesn't have the specified attribute or doesn't use an
      // encrypted resource 
      resolve(null);
    }
  });
}

// because encrypted 'js' is loaded in after the DOM page has already loaded,
// they need to be ran again. this can be done by copying the script node and
// replacing the current one
function reload_js(node)
{
  // load them into an array to prevent altering the node while it is being
  // iterated on
  const to_add = [];
  const to_remove = [];
  
  for (const child_node of node.children) {
    if (child_node.nodeName == "SCRIPT") {
      const new_script_node = document.createElement("SCRIPT");
      new_script_node.innerText = child_node.innerText;
      if (child_node.src)
        new_script_node.src = child_node.src;
      
      to_remove.push(child_node);
      to_add.push(new_script_node);
    }
  }
  
  // apply changes
  for (const script_node of to_remove)
    node.removeChild(script_node);
  
  for (const script_node of to_add)
    node.appendChild(script_node);
}

async function decrypt_resource(key, url)
{
  return new Promise((resolve, reject) => {
    const enc_bin_url = url + ".enc";
    
    // load the contents of the encrypted asset using XHR
    // this means it may not work on local html pages due to CORS and needs to
    // be hosted
    
    const xhr = new XMLHttpRequest();
    xhr.open("GET", enc_bin_url);
    xhr.responseType = 'arraybuffer';
    
    xhr.onload = (e) => {
      const enc_text = new Uint8Array(xhr.response);
      
      const aes_ctr = new aesjs.ModeOfOperation.ctr(key);
      const byte_array = aes_ctr.decrypt(enc_text);
      
      const blob = new Blob([byte_array]);
      const blob_url = URL.createObjectURL(blob);
      
      resolve(blob_url);
    };
    
    xhr.send();
  });
}
</script>

    <script>
      const input_pwd = document.getElementById("pwd");
      pwd.addEventListener("keyup", (e) => {
        if (e.key == "Enter") {
          if (!page_login(pwd.value))
            alert("incorrect password");
        }
      });
    </script>
	</body>
</html>
